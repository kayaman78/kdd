#!/bin/bash
# =============================================================================
# Database Discovery and Configuration Generator
# =============================================================================
# Automatically scans running Docker containers, detects databases,
# and generates a config.yaml file for automated backups.
#
# Supported: MySQL/MariaDB, PostgreSQL, MongoDB
#
# Usage:
#   ./setup.sh [--interactive] [--docker-root /path]
#
# Options:
#   --interactive    Ask for confirmation before adding each database
#   --docker-root    Base path for Docker compose files (default: /srv/docker)
#
# For reuse on new servers:
# - Modify DOCKER_ROOT if you use a different path
# - Modify DEFAULT_NETWORK if you use a different network name
# - Script can run in interactive mode (asks for confirmation) or auto mode
# =============================================================================

set -e  # Exit on error

# -----------------------------------------------------------------------------
# CONFIGURATION
# -----------------------------------------------------------------------------
CONFIG="/config/config.yaml"
DOCKER_ROOT="${DOCKER_ROOT:-/srv/docker}"  # Base path for Docker stacks
DEFAULT_NETWORK="bridge"                    # Default Docker network
INTERACTIVE=false                           # Interactive or automatic mode

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --interactive|-i)
            INTERACTIVE=true
            shift
            ;;
        --docker-root)
            DOCKER_ROOT="$2"
            shift 2
            ;;
        --help|-h)
            echo "Usage: $0 [--interactive] [--docker-root /path]"
            echo ""
            echo "  --interactive    Ask for confirmation for each database"
            echo "  --docker-root    Base path for Docker stacks (default: /srv/docker)"
            exit 0
            ;;
        *)
            echo "Unknown argument: $1"
            exit 1
            ;;
    esac
done

# -----------------------------------------------------------------------------
# UTILITY FUNCTIONS
# -----------------------------------------------------------------------------

# Print message with timestamp
log() {
    echo "[$(date +'%Y-%m-%d %H:%M:%S')] $*"
}

# Check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Extract environment variable from Docker container
get_container_env() {
    local container="$1"
    local var="$2"
    docker inspect "$container" 2>/dev/null | \
        jq -r ".[0].Config.Env[] | select(startswith(\"$var=\")) | split(\"=\")[1]" 2>/dev/null || echo ""
}

# Add entry to YAML config if it doesn't already exist
add_entry_if_missing() {
    local section="$1"
    local name="$2"
    shift 2
    
    # Check if entry already exists in this section
    local exists=$(yq e ".${section}[] | select(.name == \"$name\") | .name" "$CONFIG" 2>/dev/null || echo "")
    
    if [ -n "$exists" ]; then
        log "  ‚Ü≥ $name already exists in config, skipping"
        return 0
    fi
    
    # Add new empty object with name
    yq eval ".${section} += [{\"name\": \"${name}\"}]" -i "$CONFIG"
    
    # Get index of newly added entry
    local idx=$(yq eval ".${section} | length - 1" "$CONFIG")
    
    # Add all additional fields
    while [ $# -gt 0 ]; do
        local key="${1%%=*}"
        local value="${1#*=}"
        
        # Use yq to set each field (handles escaping automatically)
        yq eval ".${section}[${idx}].${key} = \"${value}\"" -i "$CONFIG"
        shift
    done
    
    log "  ‚úîÔ∏è Added $name to configuration"
}

# Ask for confirmation in interactive mode
ask_confirm() {
    if [ "$INTERACTIVE" = false ]; then
        return 0  # In auto mode, always add
    fi
    
    # In interactive mode, ask for confirmation
    local prompt="$1"
    read -p "$prompt (y/N) " resp < /dev/tty
    [[ "$resp" =~ ^[yY]$ ]]
}

# -----------------------------------------------------------------------------
# INITIALIZATION
# -----------------------------------------------------------------------------
log "=== Universal DB Backup - SETUP ==="
log "Docker root: $DOCKER_ROOT"
log "Mode: $([ "$INTERACTIVE" = true ] && echo "Interactive" || echo "Automatic")"
echo

# Verify dependencies
if ! command_exists docker; then
    log "ERROR: docker not found! Mount socket: -v /var/run/docker.sock:/var/run/docker.sock"
    exit 1
fi

if ! command_exists yq; then
    log "ERROR: yq not found!"
    exit 1
fi

if ! command_exists jq; then
    log "ERROR: jq not found!"
    exit 1
fi

# Create base config.yaml if it doesn't exist
if [ ! -f "$CONFIG" ]; then
    log "config.yaml not found, creating base structure..."
    cat <<EOF > "$CONFIG"
# Database backup configuration
# Auto-generated by setup.sh
# Date: $(date +'%Y-%m-%d %H:%M:%S')

mysql: []
postgres: []
mongo: []
redis: []
EOF
    log "‚úîÔ∏è Created config.yaml"
fi

# -----------------------------------------------------------------------------
# SCAN DOCKER CONTAINERS
# -----------------------------------------------------------------------------
log "Scanning active Docker containers..."
echo

# Get list of running containers
containers=$(docker ps --format '{{.Names}}' 2>/dev/null || true)

if [ -z "$containers" ]; then
    log "‚ö†Ô∏è No running containers found!"
    exit 0
fi

# -----------------------------------------------------------------------------
# CONTAINER LOOP
# -----------------------------------------------------------------------------
while IFS= read -r container; do
    [ -z "$container" ] && continue
    
    log "Analyzing container: $container"
    
    # Get container image
    image=$(docker inspect "$container" 2>/dev/null | jq -r '.[0].Config.Image' || echo "")
    
    if [ -z "$image" ]; then
        log "  ‚ö†Ô∏è Cannot determine image, skipping"
        continue
    fi
    
    log "  Image: $image"
    
    # Extract stack name (usually container name prefix)
    # Example: nextcloud_db_1 -> nextcloud
    stackname=$(echo "$container" | sed 's/_[^_]*$//' | sed 's/_$//')
    
    # Get container network (takes first found)
    network=$(docker inspect "$container" 2>/dev/null | jq -r '.[0].NetworkSettings.Networks | keys[0]' || echo "$DEFAULT_NETWORK")
    
    
    # -------------------------------------------------------------------------
    # MYSQL / MARIADB
    # -------------------------------------------------------------------------
    if echo "$image" | grep -qiE 'mysql|mariadb'; then
        log "  üîç Detected MySQL/MariaDB"
        
        # Extract credentials from environment variables
        root_pass=$(get_container_env "$container" "MYSQL_ROOT_PASSWORD")
        db_name=$(get_container_env "$container" "MYSQL_DATABASE")
        db_user=$(get_container_env "$container" "MYSQL_USER")
        db_pass=$(get_container_env "$container" "MYSQL_PASSWORD")
        
        # Fallback for MariaDB which uses MARIADB_* instead of MYSQL_*
        [ -z "$root_pass" ] && root_pass=$(get_container_env "$container" "MARIADB_ROOT_PASSWORD")
        [ -z "$db_name" ] && db_name=$(get_container_env "$container" "MARIADB_DATABASE")
        [ -z "$db_user" ] && db_user=$(get_container_env "$container" "MARIADB_USER")
        [ -z "$db_pass" ] && db_pass=$(get_container_env "$container" "MARIADB_PASSWORD")
        
        # Determine which credentials to use (root or specific user)
        if [ -n "$root_pass" ]; then
            user="root"
            pass="$root_pass"
        elif [ -n "$db_user" ] && [ -n "$db_pass" ]; then
            user="$db_user"
            pass="$db_pass"
        else
            log "  ‚ö†Ô∏è Credentials not found in env, skipping"
            echo
            continue
        fi
        
        # Database name (use stackname if not specified)
        db_name=${db_name:-$stackname}
        
        log "  üìã Found: user=$user, db=$db_name"
        
        # In interactive mode, ask for confirmation
        if ! ask_confirm "  Add $container to config?"; then
            echo
            continue
        fi
        
        # Add to config
        add_entry_if_missing "mysql" "$stackname" \
            "host=$container" \
            "port=3306" \
            "dbname=$db_name" \
            "user=$user" \
            "password=$pass" \
            "network=$network"
    fi
    
    
    # -------------------------------------------------------------------------
    # POSTGRESQL
    # -------------------------------------------------------------------------
    if echo "$image" | grep -qiE 'postgres'; then
        log "  üîç Detected PostgreSQL"
        
        db_name=$(get_container_env "$container" "POSTGRES_DB")
        db_user=$(get_container_env "$container" "POSTGRES_USER")
        db_pass=$(get_container_env "$container" "POSTGRES_PASSWORD")
        
        if [ -z "$db_user" ] || [ -z "$db_pass" ]; then
            log "  ‚ö†Ô∏è Credentials not found, skipping"
            echo
            continue
        fi
        
        db_name=${db_name:-$stackname}
        
        log "  üìã Found: user=$db_user, db=$db_name"
        
        if ! ask_confirm "  Add $container to config?"; then
            echo
            continue
        fi
        
        add_entry_if_missing "postgres" "$stackname" \
            "host=$container" \
            "port=5432" \
            "dbname=$db_name" \
            "user=$db_user" \
            "password=$db_pass" \
            "network=$network"
    fi
    
    
    # -------------------------------------------------------------------------
    # MONGODB
    # -------------------------------------------------------------------------
    if echo "$image" | grep -qiE 'mongo'; then
        log "  üîç Detected MongoDB"
        
        # MongoDB can use various env formats - try all variants
        db_user=$(get_container_env "$container" "MONGO_INITDB_ROOT_USERNAME")
        db_pass=$(get_container_env "$container" "MONGO_INITDB_ROOT_PASSWORD")
        db_name=$(get_container_env "$container" "MONGO_INITDB_DATABASE")
        
        # Fallback for other conventions
        [ -z "$db_user" ] && db_user=$(get_container_env "$container" "MONGODB_USERNAME")
        [ -z "$db_pass" ] && db_pass=$(get_container_env "$container" "MONGODB_PASSWORD")
        [ -z "$db_name" ] && db_name=$(get_container_env "$container" "MONGODB_DATABASE")
        
        # Fallback for Unifi (uses MONGO_USER instead of MONGO_INITDB_ROOT_USERNAME)
        [ -z "$db_user" ] && db_user=$(get_container_env "$container" "MONGO_USER")
        [ -z "$db_pass" ] && db_pass=$(get_container_env "$container" "MONGO_PASS")
        [ -z "$db_name" ] && db_name=$(get_container_env "$container" "MONGO_DBNAME")
        
        # If no specific user but has root, use root
        if [ -z "$db_user" ]; then
            db_user=$(get_container_env "$container" "MONGO_INITDB_ROOT_USERNAME")
            db_pass=$(get_container_env "$container" "MONGO_INITDB_ROOT_PASSWORD")
        fi
        
        if [ -z "$db_user" ] || [ -z "$db_pass" ]; then
            log "  ‚ö†Ô∏è Credentials not found, skipping"
            echo
            continue
        fi
        
        # Database name: try various conventions, otherwise use stackname
        db_name=${db_name:-$stackname}
        
        log "  üìã Found: user=$db_user, db=$db_name"
        
        if ! ask_confirm "  Add $container to config?"; then
            echo
            continue
        fi
        
        add_entry_if_missing "mongo" "$stackname" \
            "host=$container" \
            "port=27017" \
            "dbname=$db_name" \
            "user=$db_user" \
            "password=$db_pass" \
            "authdb=admin" \
            "network=$network"
    fi
    
    
    # -------------------------------------------------------------------------
    # REDIS (Cache Detection Only)
    # -------------------------------------------------------------------------
    # Note: Redis is usually used as cache, not persistent storage
    # Only enable if you have Redis with persistent data (AOF/RDB)
    if echo "$image" | grep -qiE 'redis|valkey'; then
        log "  üîç Detected Redis/Valkey"
        log "  ‚ÑπÔ∏è  Redis backup skipped (typically used as cache)"
        log "  üí° If you need Redis backup, enable it manually in config"
        
        # Uncomment below to enable Redis backup
        : <<'REDIS_DISABLED'
        redis_pass=$(get_container_env "$container" "REDIS_PASSWORD")
        
        if ! ask_confirm "  Add $container to config?"; then
            echo
            continue
        fi
        
        add_entry_if_missing "redis" "$stackname" \
            "host=$container" \
            "port=6379" \
            "password=$redis_pass" \
            "network=$network"
REDIS_DISABLED
    fi
    
    echo
    
done <<< "$containers"


# -----------------------------------------------------------------------------
# FINAL SUMMARY
# -----------------------------------------------------------------------------
echo
log "=========================================="
log "‚úîÔ∏è Setup completed!"
log "=========================================="
log ""
log "Configuration saved to: $CONFIG"
log ""

# Show statistics
mysql_count=$(yq e '.mysql | length' "$CONFIG")
postgres_count=$(yq e '.postgres | length' "$CONFIG")
mongo_count=$(yq e '.mongo | length' "$CONFIG")
redis_count=$(yq e '.redis | length' "$CONFIG")

log "Databases found:"
log "  - MySQL/MariaDB: $mysql_count"
log "  - PostgreSQL:    $postgres_count"
log "  - MongoDB:       $mongo_count"
log "  - Redis:         $redis_count"
log ""

total=$((mysql_count + postgres_count + mongo_count + redis_count))

if [ "$total" -eq 0 ]; then
    log "‚ö†Ô∏è No databases configured!"
    log "Verify that containers are running and have correct environment variables."
    exit 1
fi

log "Next steps:"
log "1. Review config: cat $CONFIG"
log "2. Test backup:   ./backup.sh"
log "3. Setup cron for automated backups"
log ""

exit 0